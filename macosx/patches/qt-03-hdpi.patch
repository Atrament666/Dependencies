From 70dc8026447561139aadde9af309c7c36d55344b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Morten=20Johan=20S=C3=B8rvig?= <morten.sorvig@digia.com>
Date: Wed, 24 Apr 2013 14:17:16 +0200
Subject: [PATCH] Squashed Commit of high-dpi changes.

Backported from Qt 5.

Change-Id: I3f54ca2303a894ed68569e9778d70b59c5b1c282
---
 src/corelib/global/qnamespace.h           |   1 +
 src/corelib/global/qnamespace.qdoc        |   8 +
 src/gui/image/qicon.cpp                   |  97 ++++++-
 src/gui/image/qimage.cpp                  |  55 +++-
 src/gui/image/qimage.h                    |   3 +
 src/gui/image/qimage_p.h                  |   1 +
 src/gui/image/qimagereader.cpp            |   6 +
 src/gui/image/qpixmap.cpp                 |  43 +++
 src/gui/image/qpixmap.h                   |   4 +
 src/gui/image/qpixmap_mac.cpp             |  16 +-
 src/gui/image/qpixmap_mac_p.h             |   1 +
 src/gui/image/qpixmapdata.cpp             |   1 +
 src/gui/image/qpixmapdata_p.h             |   1 +
 src/gui/itemviews/qitemdelegate.cpp       |  10 +-
 src/gui/itemviews/qstyleditemdelegate.cpp |   3 +-
 src/gui/kernel/qt_cocoa_helpers_mac.mm    |  33 ++-
 src/gui/kernel/qt_cocoa_helpers_mac_p.h   |   2 +-
 src/gui/kernel/qwidget_mac.mm             |   3 +-
 src/gui/painting/qpainter.cpp             |  22 +-
 src/gui/styles/qcommonstyle.cpp           |  21 +-
 src/gui/styles/qmacstyle_mac.mm           |  23 +-
 src/gui/styles/qstyle.cpp                 |   5 +-
 src/gui/styles/qstylehelper.cpp           |   2 -
 src/gui/widgets/qlabel.cpp                |   5 +-
 tests/auto/qicon/tst_qicon.cpp            |  94 +++++-
 tests/auto/qpixmap/tst_qpixmap.cpp        |  28 ++
 tests/manual/hidpi/hidpi.pro              |  11 +
 tests/manual/hidpi/hidpi.qrc              |   9 +
 tests/manual/hidpi/main.cpp               | 461 ++++++++++++++++++++++++++++++
 tests/manual/hidpi/qticon16.png           | Bin 0 -> 1884 bytes
 tests/manual/hidpi/qticon16@2x.png        | Bin 0 -> 3187 bytes
 tests/manual/hidpi/qticon32.png           | Bin 0 -> 3187 bytes
 tests/manual/hidpi/qticon32@2x.png        | Bin 0 -> 6474 bytes
 tests/manual/hidpi/qticon64.png           | Bin 0 -> 6474 bytes
 34 files changed, 901 insertions(+), 68 deletions(-)
 create mode 100644 tests/manual/hidpi/hidpi.pro
 create mode 100644 tests/manual/hidpi/hidpi.qrc
 create mode 100644 tests/manual/hidpi/main.cpp
 create mode 100644 tests/manual/hidpi/qticon16.png
 create mode 100644 tests/manual/hidpi/qticon16@2x.png
 create mode 100644 tests/manual/hidpi/qticon32.png
 create mode 100644 tests/manual/hidpi/qticon32@2x.png
 create mode 100644 tests/manual/hidpi/qticon64.png

diff --git a/src/corelib/global/qnamespace.h b/src/corelib/global/qnamespace.h
index 155a73d..f01a230 100644
--- a/src/corelib/global/qnamespace.h
+++ b/src/corelib/global/qnamespace.h
@@ -547,6 +547,7 @@ public:
         AA_S60DisablePartialScreenInputMode = 9,
         AA_X11InitThreads = 10,
         AA_CaptureMultimediaKeys = 11,
+        AA_UseHighDpiPixmaps = 12,
 
         // Add new attributes before this line
         AA_AttributeCount
diff --git a/src/corelib/global/qnamespace.qdoc b/src/corelib/global/qnamespace.qdoc
index 9df2aeb..2f6bdbf 100644
--- a/src/corelib/global/qnamespace.qdoc
+++ b/src/corelib/global/qnamespace.qdoc
@@ -180,6 +180,14 @@
             be set before QApplication is constructed. This attribute is only supported in Symbian 
             platform.
 
+    \value AA_UseHighDpiPixmaps Make QIcon::pixmap() generate high-dpi pixmaps
+           that can be larger than the requested size. Such pixmaps will have
+           devicePixelRatio set to a value higher than 1.
+
+           After setting this attribute application code that uses pixmap
+           sizes in layout geometry calculations should typically divide by
+           QPixmap::devicePixelRatio() to get device-independent layout geometry.
+
     \omitvalue AA_AttributeCount
 */
 
diff --git a/src/gui/image/qicon.cpp b/src/gui/image/qicon.cpp
index 67fec83..97ab464 100644
--- a/src/gui/image/qicon.cpp
+++ b/src/gui/image/qicon.cpp
@@ -115,6 +115,33 @@ static void qt_cleanup_icon_cache()
     qtIconCache()->clear();
 }
 
+/*! \internal
+
+    Returns the effective device pixel ratio.
+    New public API should set a QWindow pointer, and will get the
+    the deivcePixelRatio for that window.
+
+    Old API won't have a window pointer and qApp->devicePixelRatio()
+    will be used, iff Qt::AA_UseHighDpiPixmaps is set to prevent
+    breaking old code.
+*/
+static qreal qt_effective_device_pixel_ratio()
+{
+    bool enableHighdpi = !qgetenv("QT_HIGHDPI_AWARE").isEmpty();
+    static bool hasWarned = false;
+    if (!hasWarned && enableHighdpi) {
+        qWarning("QT_HIGHDPI_AWARE is deprecated, use qApp->setAttribute(Qt::AA_UseHighDpiPixmaps) instead.");
+        hasWarned = true;
+    }
+
+    if (enableHighdpi || qApp->testAttribute(Qt::AA_UseHighDpiPixmaps)) {
+        extern CGFloat qt_mac_get_scalefactor(QWidget *);
+        return qt_mac_get_scalefactor(0);
+    }
+
+    return qreal(1.0);
+}
+
 QIconPrivate::QIconPrivate()
     : engine(0), ref(1),
     serialNum(serialNumCounter.fetchAndAddRelaxed(1)),
@@ -139,11 +166,8 @@ QPixmapIconEngine::~QPixmapIconEngine()
 
 void QPixmapIconEngine::paint(QPainter *painter, const QRect &rect, QIcon::Mode mode, QIcon::State state)
 {
-    QSize pixmapSize = rect.size();
-#if defined(Q_WS_MAC)
-    pixmapSize *= qt_mac_get_scalefactor();
-#endif
-    painter->drawPixmap(rect, pixmap(pixmapSize, mode, state));
+    QSize targetRectSize = rect.size();
+    painter->drawPixmap(rect, pixmap(targetRectSize, mode, state));
 }
 
 static inline int area(const QSize &s) { return s.width() * s.height(); }
@@ -238,9 +262,14 @@ QPixmapIconEngineEntry *QPixmapIconEngine::bestMatch(const QSize &size, QIcon::M
     return pe;
 }
 
-QPixmap QPixmapIconEngine::pixmap(const QSize &size, QIcon::Mode mode, QIcon::State state)
+QPixmap QPixmapIconEngine::pixmap(const QSize &inSize, QIcon::Mode mode, QIcon::State state)
 {
     QPixmap pm;
+    QSize size = inSize;
+#ifdef Q_WS_MAC
+    size *= qt_effective_device_pixel_ratio();
+#endif
+
     QPixmapIconEngineEntry *pe = bestMatch(size, mode, state, false);
     if (pe)
         pm = pe->pixmap;
@@ -294,11 +323,20 @@ QPixmap QPixmapIconEngine::pixmap(const QSize &size, QIcon::Mode mode, QIcon::St
         }
         QPixmapCache::insert(key % HexString<uint>(mode), pm);
     }
+
+#ifdef Q_WS_MAC
+    if (qt_effective_device_pixel_ratio() > 1 && pm.size().width() > inSize.width()) // detect high-dpi pixmap
+        pm.setDevicePixelRatio(qMax(qreal(1.0), qreal(pm.size().width()) / qreal(inSize.width())));
+#endif
     return pm;
 }
 
-QSize QPixmapIconEngine::actualSize(const QSize &size, QIcon::Mode mode, QIcon::State state)
+QSize QPixmapIconEngine::actualSize(const QSize &inSize, QIcon::Mode mode, QIcon::State state)
 {
+    QSize size = inSize;
+#ifdef Q_WS_MAC
+    size *= qt_effective_device_pixel_ratio();
+#endif
     QSize actualSize;
     if (QPixmapIconEngineEntry *pe = bestMatch(size, mode, state, true))
         actualSize = pe->size;
@@ -343,6 +381,9 @@ void QPixmapIconEngine::addFile(const QString &fileName, const QSize &_size, QIc
                 }
                 if (pe->size == QSize() && pe->pixmap.isNull()) {
                     pe->pixmap = QPixmap(pe->fileName);
+                    // Reset the devicePixelRatio. The pixmap may be loaded from a @2x file,
+                    // but be used as a 1x pixmap by QIcon.
+                    pe->pixmap.setDevicePixelRatio(1.0);
                     pe->size = pe->pixmap.size();
                 }
                 if(pe->size == size) {
@@ -672,16 +713,23 @@ qint64 QIcon::cacheKey() const
 
 /*!
   Returns a pixmap with the requested \a size, \a mode, and \a
-  state, generating one if necessary. The pixmap might be smaller than
-  requested, but never larger.
+  state, generating one if necessary.
+
+  This function has two modes. By default, the returned pixmap might
+  be smaller than requested, but never larger. Setting the Qt::AA_UseHighDpiPixmaps
+  application attribute enables support for high-dpi pixmaps and this function
+  may then return pixmaps that are larger than the requested size,
+  with a corresponding dpi scale factor.
 
-  \sa actualSize(), paint()
+  \sa actualSize(), paint(), QPixmap::devicePixelRatio()
 */
 QPixmap QIcon::pixmap(const QSize &size, Mode mode, State state) const
 {
     if (!d)
         return QPixmap();
-    return d->engine->pixmap(size, mode, state);
+
+    QPixmap pm = d->engine->pixmap(size, mode, state);
+    return pm;
 }
 
 /*!
@@ -691,6 +739,10 @@ QPixmap QIcon::pixmap(const QSize &size, Mode mode, State state) const
 
     Returns a pixmap of size QSize(\a w, \a h). The pixmap might be smaller than
     requested, but never larger.
+
+    Setting the Qt::AA_UseHighDpiPixmaps application attribute enables this
+    function to return pixmaps that are larger than the requested size. Such
+    images will have a devicePixelRatio larger than 1.
 */
 
 /*!
@@ -700,12 +752,20 @@ QPixmap QIcon::pixmap(const QSize &size, Mode mode, State state) const
 
     Returns a pixmap of size QSize(\a extent, \a extent). The pixmap might be smaller
     than requested, but never larger.
+
+    Setting the Qt::AA_UseHighDpiPixmaps application attribute enables this
+    function to return pixmaps that are larger than the requested size. Such
+    images will have a devicePixelRatio larger than 1.
 */
 
-/*!  Returns the actual size of the icon for the requested \a size, \a
+/*!
+  Returns the actual size of the icon for the requested \a size, \a
   mode, and \a state. The result might be smaller than requested, but
   never larger.
 
+  Setting the Qt::AA_UseHighDpiPixmaps application attribute enables this
+  function to return sizes that are larger than the requested size.
+
   \sa pixmap(), paint()
 */
 QSize QIcon::actualSize(const QSize &size, Mode mode, State state) const
@@ -726,7 +786,15 @@ void QIcon::paint(QPainter *painter, const QRect &rect, Qt::Alignment alignment,
 {
     if (!d || !painter)
         return;
-    QRect alignedRect = QStyle::alignedRect(painter->layoutDirection(), alignment, d->engine->actualSize(rect.size(), mode, state), rect);
+
+    // High-dpi pixmaps do not need aligmnent. Clamp actualSize to the
+    // passed in destination rect.
+    QSize actualSize = d->engine->actualSize(rect.size(), mode, state);
+    actualSize.setWidth(qMin(rect.width(), actualSize.width()));
+    actualSize.setHeight(qMin(rect.width(), actualSize.height()));
+
+    QRect alignedRect = QStyle::alignedRect(painter->layoutDirection(), alignment, actualSize , rect);
+
     d->engine->paint(painter, alignedRect, mode, state);
 }
 
@@ -1161,7 +1229,8 @@ static QSize pixmapSizeHelper(QIcon::Size which)
     int i = 0;
     if (which == QIcon::Large)
         i = 1;
-    return QSize(widths[i], heights[i]);
+    return QSize(widths[i] * qt_effective_device_pixel_ratio(),
+                 heights[i] * qt_effective_device_pixel_ratio());
 }
 
 /*!
diff --git a/src/gui/image/qimage.cpp b/src/gui/image/qimage.cpp
index 1608445..368d3a3 100644
--- a/src/gui/image/qimage.cpp
+++ b/src/gui/image/qimage.cpp
@@ -127,7 +127,7 @@ const QVector<QRgb> *qt_image_colortable(const QImage &image)
 QBasicAtomicInt qimage_serial_number = Q_BASIC_ATOMIC_INITIALIZER(1);
 
 QImageData::QImageData()
-    : ref(0), width(0), height(0), depth(0), nbytes(0), data(0),
+    : ref(0), width(0), height(0), depth(0), nbytes(0), devicePixelRatio(1.0), data(0),
 #ifdef QT3_SUPPORT
       jumptable(0),
 #endif
@@ -1500,6 +1500,7 @@ QImage QImage::copy(const QRect& r) const
 
     image.d->dpmx = dotsPerMeterX();
     image.d->dpmy = dotsPerMeterY();
+    image.d->devicePixelRatio = devicePixelRatio();
     image.d->offset = offset();
     image.d->has_alpha_clut = d->has_alpha_clut;
 #ifndef QT_NO_IMAGE_TEXT
@@ -1728,6 +1729,49 @@ QVector<QRgb> QImage::colorTable() const
     return d ? d->colortable : QVector<QRgb>();
 }
 
+/*!
+    Returns the current dpi scale factor for the image.
+
+    Common values for the scale factor is 1.0 (the default),
+    and 2.0 for images intended for display on High DPI displays.
+
+    Use this function when calculating layouts based on the
+    image size. Layout size is pixel size divided by the scale
+    factor.
+
+    \sa setScaleFactor()
+*/
+qreal QImage::devicePixelRatio() const
+{
+    if (!d)
+        return qreal(1.0);
+    return d->devicePixelRatio;
+}
+
+/*!
+    Sets the dpi scale factor for the image.
+
+    The scale factor is typically set to 2.0 when producing
+    images for high-dpi displays. This informs layout code
+    paths in Qt which use the image size that the image is
+    a high-resolution image, and not a large image.
+
+    Qt supports using the "@2x" suffix when loading
+    images from files. Loading "myicon@2x.png" will result
+    in an image with a 2x scale factor.
+
+    Setting the scale factor will also change the dpi information
+    returned by QPaindevice::metric(): Physical dpi will logical dpi
+    multiplied by the scale factor.
+
+    \sa scaleFactor()
+*/
+void QImage::setDevicePixelRatio(qreal scale)
+{
+    detach();
+    d->devicePixelRatio = scale;
+}
+
 
 /*!
     \obsolete
@@ -3894,6 +3938,7 @@ QImage QImage::convertToFormat(Format format, Qt::ImageConversionFlags flags) co
 
         image.setDotsPerMeterY(dotsPerMeterY());
         image.setDotsPerMeterX(dotsPerMeterX());
+        image.setDevicePixelRatio(devicePixelRatio());
 
 #if !defined(QT_NO_IMAGE_TEXT)
         image.d->text = d->text;
@@ -3944,6 +3989,7 @@ static QImage convertWithPalette(const QImage &src, QImage::Format format,
     QImage dest(src.size(), format);
     QIMAGE_SANITYCHECK_MEMORY(dest);
     dest.setColorTable(clut);
+    dest.setDevicePixelRatio(src.devicePixelRatio());
 
 #if !defined(QT_NO_IMAGE_TEXT)
     QString textsKeys = src.text();
@@ -4305,6 +4351,7 @@ QImage QImage::convertBitOrder(Endian bitOrder) const
 
     image.setDotsPerMeterX(dotsPerMeterX());
     image.setDotsPerMeterY(dotsPerMeterY());
+    image.setDevicePixelRatio(devicePixelRatio());
 
     image.d->colortable = d->colortable;
     return image;
@@ -4802,6 +4849,7 @@ QImage QImage::mirrored(bool horizontal, bool vertical) const
 
     result.d->colortable = d->colortable;
     result.d->has_alpha_clut = d->has_alpha_clut;
+    result.d->devicePixelRatio = d->devicePixelRatio;
 
     if (depth() == 1)
         w = (w+7)/8;
@@ -5845,11 +5893,11 @@ int QImage::metric(PaintDeviceMetric metric) const
         break;
 
     case PdmPhysicalDpiX:
-        return qRound(d->dpmx * 0.0254);
+        return qRound(d->dpmx * 0.0254 * d->devicePixelRatio);
         break;
 
     case PdmPhysicalDpiY:
-        return qRound(d->dpmy * 0.0254);
+        return qRound(d->dpmy * 0.0254 * d->devicePixelRatio);
         break;
 
     default:
@@ -6642,6 +6690,7 @@ QImage QImage::transformed(const QTransform &matrix, Qt::TransformationMode mode
 
     dImage.d->dpmx = dotsPerMeterX();
     dImage.d->dpmy = dotsPerMeterY();
+    dImage.d->devicePixelRatio = devicePixelRatio();
 
     switch (bpp) {
         // initizialize the data
diff --git a/src/gui/image/qimage.h b/src/gui/image/qimage.h
index 8746e0e..8df23a0 100644
--- a/src/gui/image/qimage.h
+++ b/src/gui/image/qimage.h
@@ -215,6 +215,9 @@ public:
     QVector<QRgb> colorTable() const;
     void setColorTable(const QVector<QRgb> colors);
 
+    qreal devicePixelRatio() const;
+    void setDevicePixelRatio(qreal scale);
+
     void fill(uint pixel);
     void fill(const QColor &color);
     void fill(Qt::GlobalColor color);
diff --git a/src/gui/image/qimage_p.h b/src/gui/image/qimage_p.h
index 6ad23b3..c154f0a 100644
--- a/src/gui/image/qimage_p.h
+++ b/src/gui/image/qimage_p.h
@@ -77,6 +77,7 @@ struct Q_GUI_EXPORT QImageData {        // internal image data
     int height;
     int depth;
     int nbytes;               // number of bytes data
+    qreal devicePixelRatio;
     QVector<QRgb> colortable;
     uchar *data;
 #ifdef QT3_SUPPORT
diff --git a/src/gui/image/qimagereader.cpp b/src/gui/image/qimagereader.cpp
index abe375c..bf3086e 100644
--- a/src/gui/image/qimagereader.cpp
+++ b/src/gui/image/qimagereader.cpp
@@ -128,6 +128,7 @@
 #include <qsize.h>
 #include <qcolor.h>
 #include <qvariant.h>
+#include <qdebug.h>
 
 // factory loader
 #include <qcoreapplication.h>
@@ -1263,6 +1264,11 @@ bool QImageReader::read(QImage *image)
         }
     }
 
+    // successful read; check for "@2x" suffix and set scale factor
+    if (QFileInfo(fileName()).baseName().endsWith("@2x")) {
+        image->setDevicePixelRatio(2.0);
+    }
+
     return true;
 }
 
diff --git a/src/gui/image/qpixmap.cpp b/src/gui/image/qpixmap.cpp
index 9198545..d7d2f99 100644
--- a/src/gui/image/qpixmap.cpp
+++ b/src/gui/image/qpixmap.cpp
@@ -779,6 +779,49 @@ void QPixmap::setMask(const QBitmap &mask)
     data->setMask(mask);
 }
 
+/*!
+    Returns the current dpi scale factor for the pixmap.
+
+    Common values for the scale factor is 1.0 (the default),
+    and 2.0 for images intended for display on High DPI displays.
+
+    Use this function when calculating layouts based on the
+    pixmap size. Layout size is pixel size divided by the scale
+    factor.
+
+    \sa setScaleFactor(), QIcon::pixmap()
+*/
+qreal QPixmap::devicePixelRatio() const
+{
+    if (!data)
+        return qreal(1.0);
+    return data->devicePixelRatio;
+}
+
+/*!
+    Sets the dpi scale factor for the pixmap.
+
+    The scale factor is typically set to 2.0 when producing
+    pixmap for high-dpi displays. This informs layout code
+    paths in Qt which use the image size that the image is
+    a high-resolution image, and not a large image.
+
+    Qt supports using the "@2x" suffix when loading
+    pixmap from files. Loading "myicon@2x.png" will result
+    in an image with a 2x scale factor.
+
+    Setting the scale factor will also change the dpi information
+    returned by QPainDevice::metric(): Physical dpi is logical dpi
+    multiplied by the scale factor.
+
+    \sa scaleFactor()
+*/
+void QPixmap::setDevicePixelRatio(qreal scaleFactor)
+{
+    detach();
+    data->devicePixelRatio = scaleFactor;
+}
+
 #ifndef QT_NO_IMAGE_HEURISTIC_MASK
 /*!
     Creates and returns a heuristic mask for this pixmap.
diff --git a/src/gui/image/qpixmap.h b/src/gui/image/qpixmap.h
index 38deac5..630cf6b 100644
--- a/src/gui/image/qpixmap.h
+++ b/src/gui/image/qpixmap.h
@@ -109,6 +109,9 @@ public:
     QBitmap mask() const;
     void setMask(const QBitmap &);
 
+    qreal devicePixelRatio() const;
+    void setDevicePixelRatio(qreal scaleFactor);
+
 #ifdef QT_DEPRECATED
     QT_DEPRECATED QPixmap alphaChannel() const;
     QT_DEPRECATED void setAlphaChannel(const QPixmap &);
@@ -271,6 +274,7 @@ private:
     friend IconRef qt_mac_create_iconref(const QPixmap&);
     friend quint32 *qt_mac_pixmap_get_base(const QPixmap*);
     friend int qt_mac_pixmap_get_bytes_per_line(const QPixmap*);
+    friend void qt_mac_set_pixmap_scale(QPixmap *pixmap, int scale);
 #endif
     friend class QPixmapData;
     friend class QX11PixmapData;
diff --git a/src/gui/image/qpixmap_mac.cpp b/src/gui/image/qpixmap_mac.cpp
index 83d6a60..c8838f6 100755
--- a/src/gui/image/qpixmap_mac.cpp
+++ b/src/gui/image/qpixmap_mac.cpp
@@ -240,6 +240,7 @@ void QMacPixmapData::fromImage(const QImage &img,
     h = img.height();
     is_null = (w <= 0 || h <= 0);
     d = (pixelType() == BitmapType ? 1 : img.depth());
+    devicePixelRatio = img.devicePixelRatio();
 
     QImage image = img;
     int dd = QPixmap::defaultDepth();
@@ -391,6 +392,8 @@ QImage QMacPixmapData::toImage() const
         // exit if image was not created (out of memory)
     if (image.isNull())
         return image;
+    image.setDevicePixelRatio(devicePixelRatio);
+
     quint32 *sptr = pixels, *srow;
     const uint sbpr = bytesPerRow;
     if (format == QImage::Format_MonoLSB) {
@@ -487,6 +490,10 @@ void QMacPixmapData::setMask(const QBitmap &mask)
 
 int QMacPixmapData::metric(QPaintDevice::PaintDeviceMetric theMetric) const
 {
+
+
+    extern float qt_mac_defaultDpi_x(); //qpaintdevice_mac.cpps
+    extern float qt_mac_defaultDpi_y(); //qpaintdevice_mac.cpp
     switch (theMetric) {
     case QPaintDevice::PdmWidth:
         return w;
@@ -499,14 +506,14 @@ int QMacPixmapData::metric(QPaintDevice::PaintDeviceMetric theMetric) const
     case QPaintDevice::PdmNumColors:
         return 1 << d;
     case QPaintDevice::PdmDpiX:
-    case QPaintDevice::PdmPhysicalDpiX: {
-        extern float qt_mac_defaultDpi_x(); //qpaintdevice_mac.cpp
         return int(qt_mac_defaultDpi_x());
+    case QPaintDevice::PdmPhysicalDpiX: {
+        return int(qt_mac_defaultDpi_x() * devicePixelRatio);
     }
     case QPaintDevice::PdmDpiY:
+        return int(qt_mac_defaultDpi_x());
     case QPaintDevice::PdmPhysicalDpiY: {
-        extern float qt_mac_defaultDpi_y(); //qpaintdevice_mac.cpp
-        return int(qt_mac_defaultDpi_y());
+        return int(qt_mac_defaultDpi_y() * devicePixelRatio);
     }
     case QPaintDevice::PdmDepth:
         return d;
@@ -1200,6 +1207,7 @@ void QMacPixmapData::copy(const QPixmapData *data, const QRect &rect)
     has_alpha = macData->has_alpha;
     has_mask = macData->has_mask;
     uninit = false;
+    devicePixelRatio = macData->devicePixelRatio;
 
     const int x = rect.x();
     const int y = rect.y();
diff --git a/src/gui/image/qpixmap_mac_p.h b/src/gui/image/qpixmap_mac_p.h
index 534fa859..02279d2 100644
--- a/src/gui/image/qpixmap_mac_p.h
+++ b/src/gui/image/qpixmap_mac_p.h
@@ -126,6 +126,7 @@ private:
     friend void qt_mac_cgimage_data_free(void *, const void*, size_t);
     friend IconRef qt_mac_create_iconref(const QPixmap&);
     friend CGContextRef qt_mac_cg_context(const QPaintDevice*);
+    friend void qt_mac_set_pixmap_scale(QPixmap *pixmap, int devicePixelRatio);
     friend QColor qcolorForThemeTextColor(ThemeTextColor themeColor);
 };
 
diff --git a/src/gui/image/qpixmapdata.cpp b/src/gui/image/qpixmapdata.cpp
index c576eb7..146fed7 100644
--- a/src/gui/image/qpixmapdata.cpp
+++ b/src/gui/image/qpixmapdata.cpp
@@ -70,6 +70,7 @@ QPixmapData::QPixmapData(PixelType pixelType, int objectId)
       h(0),
       d(0),
       is_null(true),
+      devicePixelRatio(1.0),
       ref(0),
       detach_no(0),
       type(pixelType),
diff --git a/src/gui/image/qpixmapdata_p.h b/src/gui/image/qpixmapdata_p.h
index 23c19d5..5e483c0 100644
--- a/src/gui/image/qpixmapdata_p.h
+++ b/src/gui/image/qpixmapdata_p.h
@@ -155,6 +155,7 @@ protected:
     int h;
     int d;
     bool is_null;
+    qreal devicePixelRatio;
 
 private:
     friend class QPixmap;
diff --git a/src/gui/itemviews/qitemdelegate.cpp b/src/gui/itemviews/qitemdelegate.cpp
index 4eef7bb..e7b330d 100644
--- a/src/gui/itemviews/qitemdelegate.cpp
+++ b/src/gui/itemviews/qitemdelegate.cpp
@@ -1084,10 +1084,12 @@ QRect QItemDelegate::rect(const QStyleOptionViewItem &option,
         switch (value.type()) {
         case QVariant::Invalid:
             break;
-        case QVariant::Pixmap:
-            return QRect(QPoint(0, 0), qvariant_cast<QPixmap>(value).size());
-        case QVariant::Image:
-            return QRect(QPoint(0, 0), qvariant_cast<QImage>(value).size());
+        case QVariant::Pixmap: {
+            const QPixmap &pixmap = qvariant_cast<QPixmap>(value);
+            return QRect(QPoint(0, 0), pixmap.size() / pixmap.devicePixelRatio() ); }
+        case QVariant::Image: {
+            const QImage &image = qvariant_cast<QImage>(value);
+            return QRect(QPoint(0, 0), image.size() /  image.devicePixelRatio() ); }
         case QVariant::Icon: {
             QIcon::Mode mode = d->iconMode(option.state);
             QIcon::State state = d->iconState(option.state);
diff --git a/src/gui/itemviews/qstyleditemdelegate.cpp b/src/gui/itemviews/qstyleditemdelegate.cpp
index eef1403..e955988 100644
--- a/src/gui/itemviews/qstyleditemdelegate.cpp
+++ b/src/gui/itemviews/qstyleditemdelegate.cpp
@@ -356,7 +356,8 @@ void QStyledItemDelegate::initStyleOption(QStyleOptionViewItem *option,
                 else
                     mode = QIcon::Normal;
                 QIcon::State state = option->state & QStyle::State_Open ? QIcon::On : QIcon::Off;
-                v4->decorationSize = v4->icon.actualSize(option->decorationSize, mode, state);
+                QSize actualSize = v4->icon.actualSize(option->decorationSize, mode, state);
+                v4->decorationSize = QSize(qMin(v4->decorationSize.width(), actualSize.width()), qMin(v4->decorationSize.height(), actualSize.height()));
                 break;
             }
             case QVariant::Color: {
diff --git a/src/gui/kernel/qt_cocoa_helpers_mac.mm b/src/gui/kernel/qt_cocoa_helpers_mac.mm
index 1f2fbb9..e942d8e 100644
--- a/src/gui/kernel/qt_cocoa_helpers_mac.mm
+++ b/src/gui/kernel/qt_cocoa_helpers_mac.mm
@@ -1555,14 +1555,43 @@
 #endif
 }
 
-CGFloat qt_mac_get_scalefactor()
-{
 #ifndef QT_MAC_USE_COCOA
+CGFloat qt_mac_get_scalefactor(QWidget* window)
+{
+    Q_UNUSED(window);
     return HIGetScaleFactor();
-#else
-    return [[NSScreen mainScreen] userSpaceScaleFactor];
+}
 #endif
+
+#if QT_MAC_USE_COCOA
+CGFloat qt_mac_get_scalefactor(QWidget *window)
+    {
+    // No high-dpi support on 10.6 and below
+#if (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)
+    NSScreen *mainScreen = [NSScreen mainScreen];
+    if ([mainScreen respondsToSelector:@selector(backingScaleFactor)])
+        return [mainScreen backingScaleFactor];
+    if (QSysInfo::MacintoshVersion >= QSysInfo::MV_10_7) {
+        if (window == 0) {
+            // If there is no window given we answer the question
+            // "Are there any HiDPI screens connected?" by returning
+            // the highest scale factor found.
+            CGFloat highestScaleFactor = 1.0;
+            NSArray *screens = [NSScreen screens];
+            for (id screen in screens) {
+                highestScaleFactor = qMax(highestScaleFactor, [screen backingScaleFactor]);
+            }
+            return highestScaleFactor;
+        } else {
+            return [qt_mac_window_for(window) backingScaleFactor];
+        }
+    } else
+#endif
+    {
+        return 1.0; // return 1.0 when compiled on or running on 10.6 and lower.
+    }
 }
+#endif
 
 QString qt_mac_get_pasteboardString(OSPasteboardRef paste)
 {
diff --git a/src/gui/kernel/qt_cocoa_helpers_mac_p.h b/src/gui/kernel/qt_cocoa_helpers_mac_p.h
index 5786f92..cd84981 100644
--- a/src/gui/kernel/qt_cocoa_helpers_mac_p.h
+++ b/src/gui/kernel/qt_cocoa_helpers_mac_p.h
@@ -204,7 +204,7 @@ void *qt_mac_QStringListToNSMutableArrayVoid(const QStringList &list);
 
 void qt_syncCocoaTitleBarButtons(OSWindowRef window, QWidget *widgetForWindow);
 
-CGFloat qt_mac_get_scalefactor();
+Q_GUI_EXPORT CGFloat qt_mac_get_scalefactor(QWidget *window = 0);
 QString qt_mac_get_pasteboardString(OSPasteboardRef paste);
 
 #ifdef __OBJC__
diff --git a/src/gui/kernel/qwidget_mac.mm b/src/gui/kernel/qwidget_mac.mm
index 702a56b..19ec9ce 100644
--- a/src/gui/kernel/qwidget_mac.mm
+++ b/src/gui/kernel/qwidget_mac.mm
@@ -3279,8 +3279,7 @@ void QWidgetPrivate::setWindowIcon_sys(bool forceReset)
         if (icon.isNull()) {
             [iconButton setImage:nil];
         } else {
-            QPixmap scaled = pm->scaled(QSize(16,16), Qt::KeepAspectRatio, Qt::SmoothTransformation);
-            NSImage *image = static_cast<NSImage *>(qt_mac_create_nsimage(scaled));
+            NSImage *image = static_cast<NSImage *>(qt_mac_create_nsimage(*pm));
             [iconButton setImage:image];
             [image release];
         }
diff --git a/src/gui/painting/qpainter.cpp b/src/gui/painting/qpainter.cpp
index 7c22bde..9477cc0 100644
--- a/src/gui/painting/qpainter.cpp
+++ b/src/gui/painting/qpainter.cpp
@@ -5389,7 +5389,8 @@ void QPainter::drawPixmap(const QPointF &p, const QPixmap &pm)
             x += d->state->matrix.dx();
             y += d->state->matrix.dy();
         }
-        d->engine->drawPixmap(QRectF(x, y, w, h), pm, QRectF(0, 0, w, h));
+        int scale = pm.devicePixelRatio();
+        d->engine->drawPixmap(QRectF(x, y, w / scale, h / scale), pm, QRectF(0, 0, w, h));
     }
 }
 
@@ -5419,6 +5420,11 @@ void QPainter::drawPixmap(const QRectF &r, const QPixmap &pm, const QRectF &sr)
     qreal sw = sr.width();
     qreal sh = sr.height();
 
+    // Get pixmap scale. Use it when calculating the target
+    // rect size from pixmap size. For example, a 2X 64x64 pixel
+    // pixmap should result in a 32x32 point target rect.
+    const int pmscale = pm.devicePixelRatio();
+
     // Sanity-check clipping
     if (sw <= 0)
         sw = pm.width() - sx;
@@ -5427,9 +5433,9 @@ void QPainter::drawPixmap(const QRectF &r, const QPixmap &pm, const QRectF &sr)
         sh = pm.height() - sy;
 
     if (w < 0)
-        w = sw;
+        w = sw / pmscale;
     if (h < 0)
-        h = sh;
+        h = sh / pmscale;
 
     if (sx < 0) {
         qreal w_ratio = sx * w/sw;
@@ -5518,7 +5524,7 @@ void QPainter::drawPixmap(const QRectF &r, const QPixmap &pm, const QRectF &sr)
             x += d->state->matrix.dx();
             y += d->state->matrix.dy();
         }
-        d->engine->drawPixmap(QRectF(x, y, w, h), pm, QRectF(sx, sy, sw, sh));
+        d->engine->drawPixmap(QRectF(x, y, w , h), pm, QRectF(sx, sy, sw, sh));
     }
 }
 
@@ -5677,7 +5683,8 @@ void QPainter::drawImage(const QPointF &p, const QImage &image)
         y += d->state->matrix.dy();
     }
 
-    d->engine->drawImage(QRectF(x, y, w, h), image, QRectF(0, 0, w, h), Qt::AutoColor);
+    int scale = image.devicePixelRatio();
+    d->engine->drawImage(QRectF(x, y, w / scale, h / scale), image, QRectF(0, 0, w, h), Qt::AutoColor);
 }
 
 void QPainter::drawImage(const QRectF &targetRect, const QImage &image, const QRectF &sourceRect,
@@ -5696,6 +5703,7 @@ void QPainter::drawImage(const QRectF &targetRect, const QImage &image, const QR
     qreal sy = sourceRect.y();
     qreal sw = sourceRect.width();
     qreal sh = sourceRect.height();
+    int imageScale = image.devicePixelRatio();
 
     // Sanity-check clipping
     if (sw <= 0)
@@ -5705,9 +5713,9 @@ void QPainter::drawImage(const QRectF &targetRect, const QImage &image, const QR
         sh = image.height() - sy;
 
     if (w < 0)
-        w = sw;
+        w = sw / imageScale;
     if (h < 0)
-        h = sh;
+        h = sh / imageScale;
 
     if (sx < 0) {
         qreal w_ratio = sx * w/sw;
diff --git a/src/gui/styles/qcommonstyle.cpp b/src/gui/styles/qcommonstyle.cpp
index 1e5b7a9..f414fb2 100644
--- a/src/gui/styles/qcommonstyle.cpp
+++ b/src/gui/styles/qcommonstyle.cpp
@@ -1172,6 +1172,8 @@ void QCommonStylePrivate::tabLayout(const QStyleOptionTabV3 *opt, const QWidget
         QSize tabIconSize = opt->icon.actualSize(iconSize,
                         (opt->state & QStyle::State_Enabled) ? QIcon::Normal : QIcon::Disabled,
                         (opt->state & QStyle::State_Selected) ? QIcon::On : QIcon::Off  );
+        // High-dpi icons do not need adjustmet; make sure tabIconSize is not larger than iconSize
+        tabIconSize = QSize(qMin(tabIconSize.width(), iconSize.width()), qMin(tabIconSize.height(), iconSize.width()));
 
         *iconRect = QRect(tr.left(), tr.center().y() - tabIconSize.height() / 2,
                     tabIconSize.width(), tabIconSize .height());
@@ -1253,8 +1255,11 @@ void QCommonStyle::drawControl(ControlElement element, const QStyleOption *opt,
                     state = QIcon::On;
 
                 QPixmap pixmap = button->icon.pixmap(button->iconSize, mode, state);
-                int labelWidth = pixmap.width();
-                int labelHeight = pixmap.height();
+
+                int pixmapWidth = pixmap.width() / pixmap.devicePixelRatio();
+                int pixmapHeight = pixmap.height() / pixmap.devicePixelRatio();
+                int labelWidth = pixmapWidth;
+                int labelHeight = pixmapHeight;
                 int iconSpacing = 4;//### 4 is currently hardcoded in QPushButton::sizeHint()
                 int textWidth = button->fontMetrics.boundingRect(opt->rect, tf, button->text).width();
                 if (!button->text.isEmpty())
@@ -1262,7 +1267,7 @@ void QCommonStyle::drawControl(ControlElement element, const QStyleOption *opt,
 
                 iconRect = QRect(textRect.x() + (textRect.width() - labelWidth) / 2,
                                  textRect.y() + (textRect.height() - labelHeight) / 2,
-                                 pixmap.width(), pixmap.height());
+                                 pixmapWidth, pixmapHeight);
 
                 iconRect = visualRect(button->direction, textRect, iconRect);
 
@@ -1534,9 +1539,9 @@ void QCommonStyle::drawControl(ControlElement element, const QStyleOption *opt,
             if (!header->icon.isNull()) {
                 QPixmap pixmap
                     = header->icon.pixmap(proxy()->pixelMetric(PM_SmallIconSize), (header->state & State_Enabled) ? QIcon::Normal : QIcon::Disabled);
-                int pixw = pixmap.width();
+                int pixw = pixmap.width() / pixmap.devicePixelRatio();
 
-                QRect aligned = alignedRect(header->direction, QFlag(header->iconAlignment), pixmap.size(), rect);
+                QRect aligned = alignedRect(header->direction, QFlag(header->iconAlignment), pixmap.size() / pixmap.devicePixelRatio(), rect);
                 QRect inter = aligned.intersected(rect);
                 p->drawPixmap(inter.x(), inter.y(), pixmap, inter.x() - aligned.x(), inter.y() - aligned.y(), inter.width(), inter.height());
 
@@ -1591,7 +1596,7 @@ void QCommonStyle::drawControl(ControlElement element, const QStyleOption *opt,
                         mode = QIcon::Normal;
                     pm = toolbutton->icon.pixmap(toolbutton->rect.size().boundedTo(toolbutton->iconSize),
                                                  mode, state);
-                    pmSize = pm.size();
+                    pmSize = pm.size() / pm.devicePixelRatio();
                 }
 
                 if (toolbutton->toolButtonStyle != Qt::ToolButtonIconOnly) {
@@ -1814,8 +1819,8 @@ void QCommonStyle::drawControl(ControlElement element, const QStyleOption *opt,
                 tr = cr;
                 tr.adjust(4, 0, -8, 0);
             } else {
-                int iw = pm.width() + 4;
-                ih = pm.height();
+                int iw = pm.width() / pm.devicePixelRatio() + 4;
+                ih = pm.height()/ pm.devicePixelRatio();
                 ir = QRect(cr.left() + 4, cr.top(), iw + 2, ih);
                 tr = QRect(ir.right(), cr.top(), cr.width() - ir.right() - 4, cr.height());
             }
diff --git a/src/gui/styles/qmacstyle_mac.mm b/src/gui/styles/qmacstyle_mac.mm
index 8fbaff4..d2242ab 100644
--- a/src/gui/styles/qmacstyle_mac.mm
+++ b/src/gui/styles/qmacstyle_mac.mm
@@ -3257,9 +3257,9 @@ void QMacStyle::drawControl(ControlElement ce, const QStyleOption *opt, QPainter
                 QPixmap pixmap = header->icon.pixmap(proxy()->pixelMetric(PM_SmallIconSize), mode);
 
                 QRect pixr = header->rect;
-                pixr.setY(header->rect.center().y() - (pixmap.height() - 1) / 2);
+                pixr.setY(header->rect.center().y() - (pixmap.height() / pixmap.devicePixelRatio() - 1) / 2);
                 proxy()->drawItemPixmap(p, pixr, Qt::AlignVCenter, pixmap);
-                textr.translate(pixmap.width() + 2, 0);
+                textr.translate(pixmap.width() / pixmap.devicePixelRatio() + 2, 0);
             }
 
             proxy()->drawItemText(p, textr, header->textAlignment | Qt::AlignVCenter, header->palette,
@@ -3311,15 +3311,15 @@ void QMacStyle::drawControl(ControlElement ce, const QStyleOption *opt, QPainter
                             if (tb->toolButtonStyle == Qt::ToolButtonTextUnderIcon) {
                                 QMainWindow *mw = qobject_cast<QMainWindow *>(w->window());
                                 if (mw && mw->unifiedTitleAndToolBarOnMac()) {
-                                    pr.setHeight(pixmap.size().height());
+                                    pr.setHeight(pixmap.size().height() / pixmap.devicePixelRatio());
                                     cr.adjust(0, pr.bottom() + 1, 0, 1);
                                 } else {
-                                    pr.setHeight(pixmap.size().height() + 6);
+                                    pr.setHeight(pixmap.size().height() / pixmap.devicePixelRatio() + 6);
                                     cr.adjust(0, pr.bottom(), 0, -3);
                                 }       
                                 alignment |= Qt::AlignCenter;
                             } else {
-                                pr.setWidth(pixmap.width() + 8);
+                                pr.setWidth(pixmap.width() / pixmap.devicePixelRatio() + 8);
                                 cr.adjust(pr.right(), 0, 0, 0);
                                 alignment |= Qt::AlignLeft | Qt::AlignVCenter;
                             }
@@ -3510,10 +3510,12 @@ void QMacStyle::drawControl(ControlElement ce, const QStyleOption *opt, QPainter
                         if (btn->state & State_On)
                             state = QIcon::On;
                         QPixmap pixmap = btn->icon.pixmap(btn->iconSize, mode, state);
-                        contentW += pixmap.width() + QMacStylePrivate::PushButtonContentPadding;
+                        int pixmapWidth = pixmap.width() / pixmap.devicePixelRatio();
+                        int pixmapHeight = pixmap.height() / pixmap.devicePixelRatio();
+                        contentW += pixmapWidth + QMacStylePrivate::PushButtonContentPadding;
                         int iconLeftOffset = freeContentRect.x() + (freeContentRect.width() - contentW) / 2;
-                        int iconTopOffset = freeContentRect.y() + (freeContentRect.height() - pixmap.height()) / 2;
-                        QRect iconDestRect(iconLeftOffset, iconTopOffset, pixmap.width(), pixmap.height());
+                        int iconTopOffset = freeContentRect.y() + (freeContentRect.height() - pixmapHeight) / 2;
+                        QRect iconDestRect(iconLeftOffset, iconTopOffset, pixmapWidth, pixmapHeight);
                         QRect visualIconDestRect = visualRect(btn->direction, freeContentRect, iconDestRect);
                         proxy()->drawItemPixmap(p, visualIconDestRect, Qt::AlignLeft | Qt::AlignVCenter, pixmap);
                         int newOffset = iconDestRect.x() + iconDestRect.width()
@@ -3943,8 +3945,8 @@ void QMacStyle::drawControl(ControlElement ce, const QStyleOption *opt, QPainter
                     iconSize = comboBox->iconSize();
                 }
                 QPixmap pixmap = mi->icon.pixmap(iconSize, mode);
-                int pixw = pixmap.width();
-                int pixh = pixmap.height();
+                int pixw = pixmap.width() / pixmap.devicePixelRatio();
+                int pixh = pixmap.height() / pixmap.devicePixelRatio();
                 QRect cr(xpos, contentRect.y(), checkcol, contentRect.height());
                 QRect pmr(0, 0, pixw, pixh);
                 pmr.moveCenter(cr.center());
@@ -6038,6 +6040,7 @@ QIcon QMacStyle::standardIconImplementation(StandardPixmap standardIcon, const Q
         QPixmap pixmap(qt_mac_toolbar_ext);
         if (standardIcon == SP_ToolBarVerticalExtensionButton) {
             QPixmap pix2(pixmap.height(), pixmap.width());
+            pix2.setDevicePixelRatio(pixmap.devicePixelRatio());
             pix2.fill(Qt::transparent);
             QPainter p(&pix2);
             p.translate(pix2.width(), 0);
diff --git a/src/gui/styles/qstyle.cpp b/src/gui/styles/qstyle.cpp
index 8a5b1a9..d3f7c52 100644
--- a/src/gui/styles/qstyle.cpp
+++ b/src/gui/styles/qstyle.cpp
@@ -555,10 +555,11 @@ void QStyle::drawItemText(QPainter *painter, const QRect &rect, int alignment, c
 void QStyle::drawItemPixmap(QPainter *painter, const QRect &rect, int alignment,
                             const QPixmap &pixmap) const
 {
-    QRect aligned = alignedRect(QApplication::layoutDirection(), QFlag(alignment), pixmap.size(), rect);
+    int scale = pixmap.devicePixelRatio();
+    QRect aligned = alignedRect(QApplication::layoutDirection(), QFlag(alignment), pixmap.size() / scale, rect);
     QRect inter = aligned.intersected(rect);
 
-    painter->drawPixmap(inter.x(), inter.y(), pixmap, inter.x() - aligned.x(), inter.y() - aligned.y(), inter.width(), inter.height());
+    painter->drawPixmap(inter.x(), inter.y(), pixmap, inter.x() - aligned.x(), inter.y() - aligned.y(), inter.width() * scale, inter.height() * scale);
 }
 
 /*!
diff --git a/src/gui/styles/qstylehelper.cpp b/src/gui/styles/qstylehelper.cpp
index ce348ea..692d806 100644
--- a/src/gui/styles/qstylehelper.cpp
+++ b/src/gui/styles/qstylehelper.cpp
@@ -91,8 +91,6 @@ qreal dpiScaled(qreal value)
             ReleaseDC(0, hdcScreen);
             scale = dpi/96.0;
         }
-#elif defined(Q_WS_MAC)
-    scale = qt_mac_get_scalefactor();
 #endif
     }
     return value * scale;
diff --git a/src/gui/widgets/qlabel.cpp b/src/gui/widgets/qlabel.cpp
index 6571814..bf12c41 100644
--- a/src/gui/widgets/qlabel.cpp
+++ b/src/gui/widgets/qlabel.cpp
@@ -644,10 +644,11 @@ QSize QLabelPrivate::sizeForWidth(int w) const
     int vextra = hextra;
     QFontMetrics fm = q->fontMetrics();
 
-    if (pixmap && !pixmap->isNull())
+    if (pixmap && !pixmap->isNull()) {
         br = pixmap->rect();
+        br.setSize(br.size() / pixmap->devicePixelRatio());
 #ifndef QT_NO_PICTURE
-    else if (picture && !picture->isNull())
+    } else if (picture && !picture->isNull())
         br = picture->boundingRect();
 #endif
 #ifndef QT_NO_MOVIE
-- 
1.7.12.4 (Apple Git-37)

